# basic-shell
One of the assignments in the system programming course.
Everything that was asked to be implemented can be found in hw1-spring-2023.pdf.


Details about my code (GR):
`Για δημιουργία εκτελέσιμου: make, για εκτέλεση: ./mysh`


Ο χρήστης δίνει μια πρόταση μίας ή πολλών εντολών (κάθε λέξη χωρισμένη με κενό, πλην του ';') και σπάω την πρόταση αυτή σε επιμέρους εντολές, αποθηκεύοντας την αρχική πρόταση
σε τριδιάστατο πίνακα char *** command,όπου command[i][j] είναι η j-οστή λέξη της i-οστής εντολής.
Είμαι κάπως σπάταλος με τη μνήμη, καθώς οι πίνακες που αποθηκεύουν εντολές είναι μεγέθους <πλήθος εντολών> x MAXSIZE x MAXSIZE,δηλαδή κάθε εντολή θεωρώ έχει το πολύ MAXSIZE 
λέξεις, όπου κάθε λέξη είναι μήκους το πολύ MAXSIZE. Πέρα από αυτό, κάνω παντού free όταν δεν χρειάζομαι πλέον τη μνήμη που δέσμευσα. Συνεπώς, δεν υπάρχουν leaks.
Σε περίπτωση που η εντολή περιέχει pipelining,σπάω αυτήν τη μία εντολή  στις επιμέρους εντολές που την απαρτίζουν.
Χρησιμοποιώ πίνακες για να αποθηκεύσω τα διάφορα δεδομένα, εκτός από τα aliases και τα pid's,στα οποία χρησιμοποιώ λίστες για να τα διαχειριστώ.Επίσης το κάθε alias
είναι ενα struct που περιέχει το όνομα του alias και έναν πίνακα πρακτικά MAXSIZE x MAXSIZE.
Κάποια πράγματα που οφείλω να επισημάνω σχετικά με την υλοποίησή μου:
   1. Θεωρώ πως ο χρήστης έχει πληκτρολογήσει σωστά τα εισαγωγικά.
   2. ΔΕΝ υποστηρίζω strings, τα εισαγωγικά χρησιμοποιούνται μόνο για την εντολή createalias,όπου και εκεί, όταν αποθηκεύω τη λειτουργία του alias, αφαιρώ τα εισαγωγικά.
   3. Λειτουργούν ΜΟΝΟ τα διπλά εισαγωγικά, όχι τα μονά.
   4. Δεν χειρίζομαι environment variables, παρά μόνο στην εντολή "cd", η οποία αν εκτελεστεί χωρίς όρισμα, πηγαίνει στο $HOME path.
   5. Σε διασωληνώσεις, από τις βασικές εντολές λειτουργούν μόνο οι myHistory και aliases,η οποία εκτυπώνει τα υπάρχοντα aliases. 
   6. Αν δώθηκαν πάνω από μία εντολές μαζί, στο ιστορικό αναγράφεται κάθε μία ξεχωριστά.
   7. Το shell μου τερματίζει με την εντολή quit.
Με λίγα λόγια εξηγώ παρακάτω τη λειτουργία των συναρτήσεών μου:
-Η main μου απλά καλεί τη shell, η οποία λειτουργεί σαν το κέλυφός μου.
	
-shell: Ξεκινώντας, αρχικοποιεί τις λίστες για aliases και zombie pid's -διεργασίες δηλαδή που τελείωσαν και σπαταλούν πόρους επειδή δεν έχω κάνει wait για αυτές-, τη δομή του ιστορικού, η οποία είναι και αυτή ένας πίνακας char 20 x MAXSIZE x MAXSIZE , τον οποίο χειρίζομαι όπως τον πίνακα command.Επαναληπτικά η shell διαβάζει την είσοδο, κάνει parse και γεμίζει τον πίνακα command, εκτελεί όλες τις εντολές που περιέχει ο πίνακας command και μετά την εκτέλεση κάθε εντολής, ελέγχει αν η διεργασία που γύρισε σε αυτή είναι παιδί ή ο γονέας, όπου και κάνει τις αντίστοιχες αποδεσμεύσεις.Επειδή τα περιεχόμενα του πίνακα command μπορεί να αλλάξουν σε πολλές περιπτώσεις, από το να κάνω free κελιά τα οποία δεν χρησιμοποιώ εκείνη τη στιγμή και να ελέγχω μετά ποιες θέσεις δείχνουν σε μνήμη, έχω τον πίνακα indexes_array, ο οποίος αποθηκεύει πόσες λέξεις έχει κάθε 
εντολή και ενημερώνεται με κάθε τροποποίηση της command.
	
-execute: Εδώ γίνονται όλες οι εκτελέσεις και καλεί συναρτήσεις για τυχόν τροποποιήσεις του πίνακα command. Αρχικά, ελέγχω τι είδους εντολή δώθηκε κάθε φορά για εκτέλεση και κάνω την κατάλληλη πράξη. Αν πρόκειται για κάποιο alias, πρέπει να τροποποιήσω τον πίνακα command ώστε να αντικατασταθεί το alias με την πραγματική/ές εντολή/εντολές, γι' αυτό και περνάω σε αυτή δείκτη στον πίνακα command,δείκτη στον πίνακα indexes_array και δείκτη σε έναν ακέραιο, ο οποίος δείχνει πόσες εντολές υπάρχουν στον πίνακα. Εφόσον γίνει ο έλεγχος, εκτελώ την αντίστοιχη εντολή,ενημερώνεται το ιστορικό και επιστρέφει στην shell για να ξεκινήσει η execute την εκτέλεση της επόμενη εντολής. 
  Να σημειώσω δύο πράγματα:
  		i.Αν πρόκειται για εντολή με διασωλήνωση, η εντολή αυτή διασπάται στις εντολές που την απαρτίζουν και αποθηκεύονται προσωρινά στον πίνακα temp. Εκεί τις κάνω exec κάθε μία, κάνοντας wait αφού τις έχω εκτελέσει όλες, καθώς με αυτόν
τον τρόπο δε θα υπάρξει ο κίνδυνος του write block,αν αυτό που θέλω να γράψω είναι μεγαλύτερο από την χωρητικότητα του pipe.
		ii. Για το &, χρησιμοποιώ process groups.Ελέγχω αν η εντολή περιέχει τον χαρακτήρα & και αν ναι, το βάζω σε group, κρατάω το pid της διεργασίας,δεν την περιμένω να εκτελεστεί και με την επιστροφή του γονέα στη shell στην επόμενη επανάληψη ελέγχω αν κάποια από τις background εντολές τελείωσε για να κάνω wait και να την απελευθερώσω (check_for_zombies).
Ένας επίσης λόγος που επέλεξα groups είναι επειδή βόλεψε πολύ με τη διαχείριση σημάτων, καθώς με αυτή την υλοποίηση δε θα πρέπει να ανησυχώ αν κάποιο σήμα διέκοψε διεργασία άλλου group.
	
-seperate_commands:Αν η εντολή που πρόκειται να εκτελέσω είναι εντολή διασωλήνωσης, δημιουργώ τον πίνακα temp και τον array_size,που αποθηκεύω εκεί τις εντολές και το πλήθος των λέξεων κάθε φορά.Ο ακέραιος length δείχνει πόσες εντολές περιέχονται στην εντολή διασωλήνωσης.
	
-open_redirections:Δέχεται κάθε μια εντολή και αν βρει κάποιο σύμβολο ανακατεύθυνσης εισόδου/εξόδου, ανοίγει το αρχείο είτε για ανάγνση είτε για γράψιμο. Αν βρει τέτοιον χαρακτήρα, τον αφαιρεί από την εντολή για να σταλθεί στην execvp σωστά.
	
-history_get:Ελέγχει αν δώσαμε έγκυρο index([1,20]). Αν ναι, αντικαθιστά στη θέση i του πίνακα command την εντολή myHistory <αριθμός> με την τάδε εντολή για εκτέλεση.
	
-history_update:Ελέγχει αν η εντολή που δώσαμε είναι ίδια με την προηγούμενη, οπότε δεν την εισάγει ξανά. Αν όχι, την αντιγράφει στα κατάλληλα πεδία του πίνακα history.
		Παρατήρηση: Επειδή το να κρατάω δεύτερο πίνακα για κάθε έναν πίνακα εν τέλει έγινε κουραστικό, εδώ όταν γεμίζω μια γραμμή με την εντολή, τα υπόλοιπα κελιά τα κάνω free και τα βάζω να δείχνουν  NULL,ώστε να ξέρω έτσι πόσες λέξεις είναι κάθε εντολή στο ιστορικό.
	
-history_init και history_destroy δεσμεύουν και αποδεσμεύουν τον πίνακα history αντίστοιχα.
	
-input_parse:Παίρνοντας ως είσοδο την πρόταση του χρήστη, τη σπάω αρχικά ανα ';' και έπειτα ανά κενό και την κάθε λέξη που προκύπτει την βάζω στην αντίστοιχη θέση του πίνακα command,ενημερώνοντας και τον indexes_array και τον ακέραιο που δείχνει πόσες εντολές δώθηκαν ως είσοδος.
		Παρατήρηση: Στη συνάρτηση αυτή επειδή δεν χωρίζω ανά εισαγωγικά, αρχικά ψάχνω αν υπάρχουν και αν ναι, κρατάω κάθε θέση της πρότασης στην οποία υπάρχει κενό και την αλλάζω προσωρινά σε '/' ώστε να μη χωριστεί η πρόταση από την strtok με delimiter το κενό. Όταν τοποθετηθούν οι λέξεις στον πίνακα,πηγαίνω και επαναφέρω τα κενά ,όπως τα έχω κρατήσει στους πίνακες με τις θέσεις πριν το κανονικό parsing.
	
-check_correct_input:Ελέγχω αν η πρόταση που δώθηκε "στέκει", για να μην έχω προβλήματα με την εκτέλεση. Αν δω ότι δεν είναι αποδεκτής μορφής, δεν συνεχίζω να κάνω parse.
	
-alias_management:Ελέγχω αν το alias που διάβασα πρέπει να διαγραφτεί ή να προστεθεί ή να ενημερώσει κάποιο υπάρχον alias.
	
-get_alias:Με λίγα λόγια,βρίσκει τον κόμβο που υπάρχει το alias και το αντικαθιστά στον πίνακα command,κρατώντας πιθανόν λέξεις που βρίσκονται μετά το alias.Αν πρόκειται για alias το οποίο περιέχει πάνω από μία εντολές,δεσμεύω άλλον πίνακα, ο οποίος είναι αντίγραφο του command,
		   μόνο με περισσότερα στοιχεία, και εισάγω στο νέο πίνακα τις εντολές που απαρτίζουν το alias.
	
-list_append:Εισάγει το νέο alias στη λίστα.
	
-check_for_wildchars:Όπως λέει και το όνομα, ελέγχει αν υπάρχουν wildchars με τη βοήθεια της word_has_wildchar και μέσω της συνάρτησης glob επιστρέφει όλα τα αποτελέσματα και τα εισάγει στον πίνακα. Για ευκολία μου θεωρώ ότι μετά την αντικατάσταση του wildchar,το πλήθος των λέξεων της εντολής είναι μικρότερο του MAXSIZE.
	
-check_for_zombies:Ελέγχει πριν την εκτέλεση κάθε εντολής αν υπάρχουν τυχόν zombie διεργασίες, ώστε να τις αποδεσμεύσει. Χρησιμοποιώ global pointer για την κεφαλή της λίστας για να έχει ο πατέρας πρόσβαση από παντού για τυχόν λειτουργίες με τη λίστα.

Λοιπές συναρτήσεις είναι για εύρεση κάποιου στοιχείου στις λέξεις κάποιας εντολής(search_in_array) ή διαχείριση λιστών (αναζήτηση στοιχείου, αφαίρεση στοιχείου, επιστροφή πλήθους στοιχείων, δημιουργία/καταστροφή λιστών).
